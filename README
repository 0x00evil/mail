= Mail

== Introduction

Mail is an internet library for Ruby that is designed to handle emails
generation, parsing and sending in a simple, rubyesque manner.

The purpose of this library is to provide a single point of access to handle
all email functions, including sending and receiving emails.  All network
type actions are done through proxy methods to Net::SMTP, Net::POP3 etc.

Built from my experience with TMail, it is designed to be a pure ruby
implementation that makes generating, sending and parsing emails a no
brainer.

It is also designed form the ground up to work with Ruby 1.9.  This is because
Ruby 1.9 handles text encodings much more magically than Ruby 1.8.x and so
these features have been taken full advantage of in this library allowing
Mail to handle a lot more messages more cleanly than TMail.  Mail does run on
Ruby 1.8.x... it's just not as fun to code.

Finally, Mail has been designed with a very simple object oriented system
that really opens up the email messages you are parsing, if you know what
you are doing, you can fiddle with every last bit of your email directly.

== Basic Status

=== Targets For Version 1:

o RFC2822 Support, Reading and Writing - DONE
o RFC2045-2049 Support (MIME), Reading - In Testing
o RFC2045-2049 Support (MIME), Writing - I/P
o Content Encoding, Reading - Queued
o Content Encoding, Writing - Queued
o Wrappers for File, Net/POP3, Net/SMTP, Net/IMAP - I/P

=== What this means:

Mail is pretty much RFC2822 compliant now, that is, it can parse and generate
valid US-ASCII emails.  It also is quite robust, meaning, if it finds something
it doesn't understand it will not crash, instead, it will skip the problem and
keep parsing.  In the case of a header it doesn't understand, it will initialize
the header as an optional unstructured field and continue parsing.

This means Mail won't (ever) crunch your data (we think).

Part of getting mail tested will be running it through an archive of thousands
emails that are sitting in a cloud of the developers and making sure they parse,
by round tripping them through mail and comparing with the original, this isn't
done yet, but will be done soon.

We have also gotten basic mime parsing and multipart parsing working.  Mail won't
create a multipart email yet... well.. actually it can, but the API sucks right
now.

== Installation

If you are using this in production right now, you must _really_ know
what you are doing.  This is well spec'd and tested alpha code.

If you need instructions beyond "go get it from my git repo" then you
probably shouldn't be playing with Mail yet.  Wait till we've wrapped it
up into a gem.

== Usage

All major mail functions should be able to happen from the Mail:: module.

=== Making an email

 require 'mail'
 
 mail = Mail.new do
      from 'mikel@test.lindsaar.net'
        to 'you@test.lindsaar.net'
   subject 'This is a test email'
      body File.read('body.txt')
 end

 mail.to_s #=> "From: mikel@test.lindsaar.net\r\nTo: you@...

=== Making an email, have it your way:

 require 'mail'
 
 mail = Mail.new do
   body File.read('body.txt')
 end

 mail['from'] = 'mikel@test.lindsaar.net'
 mail[:to]    = 'you@test.lindsaar.net'
 mail.subject = 'This is a test email'
 
 mail.to_s #=> "From: mikel@test.lindsaar.net\r\nTo: you@...

=== Don't Worry About Message IDs:

 require 'mail'
 
 mail = Mail.new do
     to 'you@test.lindsaar.net'
   body 'Some simple body'
 end

 mail.to_s =~ /Message\-ID: <[\d\w_]+@.+.mail/ #=> 27
 
Mail will automatically add a Message-ID field if it is missing and
give it a unique, random Message-ID along the lines of:

 <4a7ff76d7016_13a81ab802e1@local.fqdn.mail>
 
=== Or do worry about Message-IDs:

 require 'mail'
 
 mail = Mail.new do
          to 'you@test.lindsaar.net'
  message_id '<ThisIsMyMessageId@some.domain.com>'
        body 'Some simple body'
 end
 
 mail.to_s =~ /Message\-ID: <ThisIsMyMessageId@some.domain.com>/ #=> 27

Mail will take the message_id you assign to it trusting that you know
what you are doing.

=== Sending an email:

 require 'mail'

 Mail.defaults do
   smtp '127.0.0.1', 25
 end

 Mail.deliver do
       from 'me@test.lindsaar.net'
         to 'you@test.lindsaar.net'
    subject 'Here is the image you wanted'
       body File.read('body.txt')
   add_file 'New Header Image', '/somefile.png'
 end

or
 
 Mail.defaults do
   smtp '127.0.0.1' # Port 25 defult
 end

 mail = Mail.new do
       from 'me@test.lindsaar.net'
         to 'you@test.lindsaar.net'
    subject 'Here is the image you wanted'
       body File.read('body.txt')
   add_file 'New Header Image', '/somefile.png'
 end
 
 mail.deliver!

=== Getting an email from a pop server:

 require 'mail'
 
 Mail.defaults do
   pop3 'mail.myhost.com.au', 110
   user 'mikel'
   pass 'mypass'
 end
 
 emails = Mail.get_all_mail
 
 emails.length #=> 12

=== Reading an Email

 require 'mail'
 
 mail = Mail.read('/path/to/message.eml')
 
 mail.envelope.from   #=> 'mikel@test.lindsaar.net'
 mail.from.addresses  #=> ['mikel@test.lindsaar.net', 'ada@test.lindsaar.net']
 mail.sender.address  #=> 'mikel@test.lindsaar.net'
 mail.to.addresses    #=> ['bob@test.lindsaar.net']
 mail.cc.addresses    #=> ['sam@test.lindsaar.net']
 mail.subject.to_s    #=> "This is the subject"
 mail.date.to_s       #=> '21 Nov 1997 09:55:06 -0600'
 mail.message_id      #=> '<4D6AA7EB.6490534@xxx.xxx>'
 mail.body            #=> 'This is the body of the email...

Many more methods available.

=== Reading a Multipart Email

 require 'mail'
 
 mail = Mail.read('multipart_email')
 
 mail.multipart?          #=> true
 mail.parts.length        #=> 2
 mail.preamble            #=> "Text before the first part"
 mail.epilogue            #=> "Text after the last part"
 mail.parts.map { |p| p.content_type }  #=> ['text/plain', 'application/pdf']
 mail.parts.map { |p| p.class }         #=> [Mail::Message, Mail::Message]
 mail.parts[0].mime_parameters          #=> {'charset' => 'ISO-8859-1'}
 mail.parts[1].mime_parameters          #=> {'name' => 'my.pdf'}

Mail generates a tree of parts.  Each message has many or no parts.  Each part
is another message which can have many or no parts.

A message will only have parts if it is a multipart/mixed or related/mixed
content type and has a boundary defined.

=== Writing a multipart/alternative (html and text) email

 mail = Mail.new do
   to 'nicolas.fouche@gmail.com'
   from 'Mikel Lindsaar <raasdnil@gmail.com>'
   subject 'First multipart email sent with Mail'
 end
 
 text_part = Mail.new
 text_part[:body] = 'This is plain text'
 
 html_part = Mail.new
 html_part[:content_type] = 'text/html; charset=UTF-8'
 html_part[:body] = '<h1>This is HTML</h1>'
 
 mail.text_part = text_part
 mail.html_part = html_part

=== Getting error reports from an email:

 require 'mail'
 
 @mail = Mail.read('/path/to/bounce_message.eml')
 
 @mail.bounced?         #=> true
 @mail.final_recipient  #=> rfc822;mikel@dont.exist.com
 @mail.action           #=> failed
 @mail.error_status     #=> 5.5.0
 @mail.diagnostic_code  #=> smtp;550 Requested action not taken: mailbox unavailable 
 @mail.retryable?       #=> false

